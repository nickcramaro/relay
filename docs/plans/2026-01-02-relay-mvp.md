# Relay MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a Rust CLI that turns MCP servers into discoverable, ergonomic command-line tools.

**Architecture:** Transport-agnostic MCP client with stdio/HTTP support. Config-driven server registry. JSON Schema to CLI flags mapper. Human-readable and JSON output renderers.

**Tech Stack:** Rust, clap (CLI), tokio (async), serde/serde_json (serialization), serde_yaml (config), reqwest (HTTP), directories (XDG paths), anyhow/thiserror (errors), owo-colors (terminal colors), tabled (output formatting)

---

## Phase 1: Project Skeleton

### Task 1: Initialize Rust Project

**Files:**
- Create: `Cargo.toml`
- Create: `src/main.rs`
- Create: `.gitignore`

**Step 1: Initialize cargo project**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo init
```
Expected: Creates Cargo.toml and src/main.rs

**Step 2: Add initial dependencies to Cargo.toml**

```toml
[package]
name = "relay"
version = "0.1.0"
edition = "2021"
description = "CLI interface for MCP servers"
license = "MIT"

[dependencies]
clap = { version = "4", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
serde_yaml = "0.9"
reqwest = { version = "0.12", features = ["json"] }
directories = "5"
anyhow = "1"
thiserror = "2"
owo-colors = "4"
tabled = "0.17"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

**Step 3: Create .gitignore**

```gitignore
/target
Cargo.lock
.DS_Store
```

**Step 4: Verify build**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo build
```
Expected: Compiles successfully

**Step 5: Initialize git, add remote, and commit**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && git init && git remote add origin git@github.com:nickcramaro/relay.git && git add -A && git commit -m "chore: initialize relay project"
```

---

### Task 2: CLI Scaffold with Clap

**Files:**
- Create: `src/cli.rs`
- Modify: `src/main.rs`

**Step 1: Write test for CLI parsing**

Create `tests/cli_test.rs`:
```rust
use assert_cmd::Command;

#[test]
fn test_cli_help() {
    let mut cmd = Command::cargo_bin("relay").unwrap();
    cmd.arg("--help").assert().success();
}

#[test]
fn test_cli_version() {
    let mut cmd = Command::cargo_bin("relay").unwrap();
    cmd.arg("--version").assert().success();
}
```

Add dev dependency to Cargo.toml:
```toml
[dev-dependencies]
assert_cmd = "2"
predicates = "3"
tempfile = "3"
```

**Step 2: Run tests to verify they fail**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test
```
Expected: FAIL (no CLI structure yet)

**Step 3: Implement CLI structure**

Create `src/cli.rs`:
```rust
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "relay")]
#[command(version, about = "CLI interface for MCP servers", long_about = None)]
pub struct Cli {
    /// Enable verbose output
    #[arg(short, long, global = true)]
    pub verbose: bool,

    /// Output format
    #[arg(long, global = true, default_value = "human")]
    pub format: OutputFormat,

    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Clone, Copy, Default, clap::ValueEnum)]
pub enum OutputFormat {
    #[default]
    Human,
    Json,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Add a new MCP server
    Add {
        /// Server name
        name: String,
        /// Transport type
        #[arg(long, value_enum)]
        transport: Transport,
        /// Command to spawn (for stdio transport)
        #[arg(long)]
        cmd: Option<String>,
        /// URL (for http transport)
        #[arg(long)]
        url: Option<String>,
        /// Environment variables (KEY=value format)
        #[arg(long, value_parser = parse_env_var)]
        env: Vec<(String, String)>,
    },
    /// List registered servers
    List,
    /// Remove a server
    Remove {
        /// Server name
        name: String,
    },
    /// Ping a server to check connectivity
    Ping {
        /// Server name
        name: String,
    },
    /// List tools from a server
    Tools {
        /// Server name (uses default if not specified)
        server: Option<String>,
    },
    /// Describe a specific tool
    Describe {
        /// Server name (uses default if not specified)
        server: Option<String>,
        /// Tool name
        tool: String,
    },
    /// Run a tool
    Run {
        /// Server name (uses default if not specified)
        server: Option<String>,
        /// Tool name
        tool: String,
        /// JSON input for the tool
        #[arg(long)]
        input_json: Option<String>,
        /// Tool arguments as flags (collected dynamically)
        #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
        args: Vec<String>,
    },
}

#[derive(Clone, Copy, clap::ValueEnum)]
pub enum Transport {
    Stdio,
    Http,
}

fn parse_env_var(s: &str) -> Result<(String, String), String> {
    let pos = s
        .find('=')
        .ok_or_else(|| format!("invalid KEY=value: no `=` found in `{s}`"))?;
    Ok((s[..pos].to_string(), s[pos + 1..].to_string()))
}
```

**Step 4: Update main.rs**

```rust
mod cli;

use clap::Parser;
use cli::Cli;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    // Initialize tracing
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive(if cli.verbose {
                    tracing::Level::DEBUG.into()
                } else {
                    tracing::Level::INFO.into()
                }),
        )
        .init();

    match cli.command {
        _ => {
            println!("Command not yet implemented");
        }
    }

    Ok(())
}
```

**Step 5: Run tests to verify they pass**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test
```
Expected: PASS

**Step 6: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add CLI scaffold with clap"
```

---

## Phase 2: Configuration System

### Task 3: Config Data Structures

**Files:**
- Create: `src/config/mod.rs`
- Create: `src/config/types.rs`

**Step 1: Write test for config serialization**

Create `src/config/mod.rs`:
```rust
mod types;

pub use types::*;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_roundtrip() {
        let config = Config {
            servers: [
                ("linear".to_string(), ServerConfig {
                    transport: TransportConfig::Stdio {
                        command: "npx @linear/mcp-server".to_string(),
                    },
                    env: [("LINEAR_API_KEY".to_string(), "${env:LINEAR_API_KEY}".to_string())]
                        .into_iter()
                        .collect(),
                }),
            ]
            .into_iter()
            .collect(),
            default_server: Some("linear".to_string()),
        };

        let yaml = serde_yaml::to_string(&config).unwrap();
        let parsed: Config = serde_yaml::from_str(&yaml).unwrap();

        assert_eq!(parsed.default_server, Some("linear".to_string()));
        assert!(parsed.servers.contains_key("linear"));
    }
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test config
```
Expected: FAIL (types don't exist)

**Step 3: Implement config types**

Create `src/config/types.rs`:
```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Config {
    #[serde(default)]
    pub servers: HashMap<String, ServerConfig>,
    pub default_server: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    #[serde(flatten)]
    pub transport: TransportConfig,
    #[serde(default)]
    pub env: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "transport", rename_all = "lowercase")]
pub enum TransportConfig {
    Stdio {
        command: String,
    },
    Http {
        url: String,
    },
}
```

**Step 4: Run test to verify it passes**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test config
```
Expected: PASS

**Step 5: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add config data structures"
```

---

### Task 4: Config Persistence

**Files:**
- Create: `src/config/store.rs`
- Modify: `src/config/mod.rs`

**Step 1: Write test for config load/save**

Add to `src/config/mod.rs`:
```rust
mod store;

pub use store::*;
```

Create `src/config/store.rs`:
```rust
use super::Config;
use anyhow::{Context, Result};
use directories::ProjectDirs;
use std::path::PathBuf;

pub struct ConfigStore {
    path: PathBuf,
}

impl ConfigStore {
    pub fn new() -> Result<Self> {
        let dirs = ProjectDirs::from("", "", "relay")
            .context("Could not determine config directory")?;
        let config_dir = dirs.config_dir();
        std::fs::create_dir_all(config_dir)?;
        Ok(Self {
            path: config_dir.join("config.yaml"),
        })
    }

    pub fn with_path(path: PathBuf) -> Self {
        Self { path }
    }

    pub fn load(&self) -> Result<Config> {
        if !self.path.exists() {
            return Ok(Config::default());
        }
        let contents = std::fs::read_to_string(&self.path)
            .with_context(|| format!("Failed to read config from {:?}", self.path))?;
        let config: Config = serde_yaml::from_str(&contents)
            .with_context(|| "Failed to parse config YAML")?;
        Ok(config)
    }

    pub fn save(&self, config: &Config) -> Result<()> {
        if let Some(parent) = self.path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        let contents = serde_yaml::to_string(config)?;
        std::fs::write(&self.path, contents)
            .with_context(|| format!("Failed to write config to {:?}", self.path))?;
        Ok(())
    }

    pub fn path(&self) -> &PathBuf {
        &self.path
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{ServerConfig, TransportConfig};
    use tempfile::tempdir;

    #[test]
    fn test_config_persistence() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("config.yaml");
        let store = ConfigStore::with_path(path);

        // Load from non-existent file returns default
        let config = store.load().unwrap();
        assert!(config.servers.is_empty());

        // Save and reload
        let mut config = Config::default();
        config.servers.insert(
            "test".to_string(),
            ServerConfig {
                transport: TransportConfig::Http {
                    url: "http://localhost:3000".to_string(),
                },
                env: Default::default(),
            },
        );
        store.save(&config).unwrap();

        let loaded = store.load().unwrap();
        assert!(loaded.servers.contains_key("test"));
    }
}
```

**Step 2: Run test to verify it passes**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test config
```
Expected: PASS

**Step 3: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add config persistence"
```

---

### Task 5: Environment Variable Interpolation

**Files:**
- Create: `src/config/interpolate.rs`
- Modify: `src/config/mod.rs`

**Step 1: Write test for env interpolation**

Create `src/config/interpolate.rs`:
```rust
use std::collections::HashMap;

/// Interpolate environment variables in a string.
/// Supports ${env:VAR_NAME} syntax.
pub fn interpolate_env(value: &str) -> String {
    let mut result = value.to_string();
    let re = regex::Regex::new(r"\$\{env:([^}]+)\}").unwrap();

    for cap in re.captures_iter(value) {
        let full_match = cap.get(0).unwrap().as_str();
        let var_name = cap.get(1).unwrap().as_str();
        if let Ok(var_value) = std::env::var(var_name) {
            result = result.replace(full_match, &var_value);
        }
    }

    result
}

/// Interpolate all env values in a HashMap
pub fn interpolate_env_map(env: &HashMap<String, String>) -> HashMap<String, String> {
    env.iter()
        .map(|(k, v)| (k.clone(), interpolate_env(v)))
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_interpolate_env() {
        std::env::set_var("TEST_VAR", "test_value");

        assert_eq!(interpolate_env("${env:TEST_VAR}"), "test_value");
        assert_eq!(interpolate_env("prefix_${env:TEST_VAR}_suffix"), "prefix_test_value_suffix");
        assert_eq!(interpolate_env("no_interpolation"), "no_interpolation");
        assert_eq!(interpolate_env("${env:NONEXISTENT}"), "${env:NONEXISTENT}");

        std::env::remove_var("TEST_VAR");
    }
}
```

Add regex to Cargo.toml:
```toml
regex = "1"
```

**Step 2: Add to mod.rs**

```rust
mod interpolate;
pub use interpolate::*;
```

**Step 3: Run test to verify it passes**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test interpolate
```
Expected: PASS

**Step 4: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add environment variable interpolation"
```

---

### Task 6: Implement Add/List/Remove Commands

**Files:**
- Create: `src/commands/mod.rs`
- Create: `src/commands/server.rs`
- Modify: `src/main.rs`

**Step 1: Write integration test**

Create `tests/server_commands_test.rs`:
```rust
use assert_cmd::Command;
use predicates::prelude::*;
use tempfile::tempdir;

fn relay_cmd(config_path: &str) -> Command {
    let mut cmd = Command::cargo_bin("relay").unwrap();
    cmd.env("RELAY_CONFIG", config_path);
    cmd
}

#[test]
fn test_add_and_list_server() {
    let dir = tempdir().unwrap();
    let config_path = dir.path().join("config.yaml");
    let config_str = config_path.to_str().unwrap();

    // Add a server
    relay_cmd(config_str)
        .args(["add", "test-server", "--transport", "http", "--url", "http://localhost:3000"])
        .assert()
        .success()
        .stdout(predicate::str::contains("Added server"));

    // List servers
    relay_cmd(config_str)
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("test-server"));

    // Remove server
    relay_cmd(config_str)
        .args(["remove", "test-server"])
        .assert()
        .success();

    // Verify removed
    relay_cmd(config_str)
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("No servers").or(predicate::str::contains("test-server").not()));
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test server_commands
```
Expected: FAIL

**Step 3: Create commands module**

Create `src/commands/mod.rs`:
```rust
mod server;

pub use server::*;
```

Create `src/commands/server.rs`:
```rust
use crate::cli::{OutputFormat, Transport};
use crate::config::{Config, ConfigStore, ServerConfig, TransportConfig};
use anyhow::{bail, Result};
use owo_colors::OwoColorize;
use std::collections::HashMap;

pub fn add_server(
    store: &ConfigStore,
    name: String,
    transport: Transport,
    cmd: Option<String>,
    url: Option<String>,
    env: Vec<(String, String)>,
    format: OutputFormat,
) -> Result<()> {
    let mut config = store.load()?;

    let transport_config = match transport {
        Transport::Stdio => {
            let command = cmd.ok_or_else(|| anyhow::anyhow!("--cmd required for stdio transport"))?;
            TransportConfig::Stdio { command }
        }
        Transport::Http => {
            let url = url.ok_or_else(|| anyhow::anyhow!("--url required for http transport"))?;
            TransportConfig::Http { url }
        }
    };

    let server_config = ServerConfig {
        transport: transport_config,
        env: env.into_iter().collect(),
    };

    config.servers.insert(name.clone(), server_config);

    // Set as default if it's the first server
    if config.default_server.is_none() {
        config.default_server = Some(name.clone());
    }

    store.save(&config)?;

    match format {
        OutputFormat::Human => {
            println!("{} Added server: {}", "✓".green(), name.cyan());
        }
        OutputFormat::Json => {
            let output = serde_json::json!({ "added": name });
            println!("{}", serde_json::to_string_pretty(&output)?);
        }
    }

    Ok(())
}

pub fn list_servers(store: &ConfigStore, format: OutputFormat) -> Result<()> {
    let config = store.load()?;

    match format {
        OutputFormat::Human => {
            if config.servers.is_empty() {
                println!("{}", "No servers registered. Use `relay add` to add one.".dimmed());
                return Ok(());
            }

            println!(
                "{:<20} {:<10} {}",
                "NAME".bold(),
                "TRANSPORT".bold(),
                "TARGET".bold()
            );
            println!("{}", "─".repeat(60).dimmed());

            for (name, server) in &config.servers {
                let (transport, target) = match &server.transport {
                    TransportConfig::Stdio { command } => ("stdio", command.as_str()),
                    TransportConfig::Http { url } => ("http", url.as_str()),
                };
                let is_default = config.default_server.as_ref() == Some(name);
                let name_display = if is_default {
                    format!("{} {}", name.cyan(), "(default)".dimmed())
                } else {
                    name.to_string()
                };
                println!("{:<20} {:<10} {}", name_display, transport.yellow(), target);
            }
        }
        OutputFormat::Json => {
            let output = serde_json::to_string_pretty(&config.servers)?;
            println!("{}", output);
        }
    }

    Ok(())
}

pub fn remove_server(store: &ConfigStore, name: String, format: OutputFormat) -> Result<()> {
    let mut config = store.load()?;

    if !config.servers.contains_key(&name) {
        bail!("Server '{}' not found", name);
    }

    config.servers.remove(&name);

    // Clear default if it was the removed server
    if config.default_server.as_ref() == Some(&name) {
        config.default_server = config.servers.keys().next().cloned();
    }

    store.save(&config)?;

    match format {
        OutputFormat::Human => {
            println!("{} Removed server: {}", "✓".green(), name.cyan());
        }
        OutputFormat::Json => {
            let output = serde_json::json!({ "removed": name });
            println!("{}", serde_json::to_string_pretty(&output)?);
        }
    }

    Ok(())
}
```

**Step 4: Update main.rs to use commands**

```rust
mod cli;
mod commands;
mod config;

use clap::Parser;
use cli::{Cli, Commands};
use config::ConfigStore;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive(if cli.verbose {
                    tracing::Level::DEBUG.into()
                } else {
                    tracing::Level::INFO.into()
                }),
        )
        .init();

    // Support RELAY_CONFIG env var for testing
    let store = if let Ok(path) = std::env::var("RELAY_CONFIG") {
        ConfigStore::with_path(path.into())
    } else {
        ConfigStore::new()?
    };

    match cli.command {
        Commands::Add { name, transport, cmd, url, env } => {
            commands::add_server(&store, name, transport, cmd, url, env, cli.format)?;
        }
        Commands::List => {
            commands::list_servers(&store, cli.format)?;
        }
        Commands::Remove { name } => {
            commands::remove_server(&store, name, cli.format)?;
        }
        _ => {
            println!("Command not yet implemented");
        }
    }

    Ok(())
}
```

**Step 5: Run test to verify it passes**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test server_commands
```
Expected: PASS

**Step 6: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: implement add, list, remove server commands"
```

---

## Phase 3: MCP Protocol Types

### Task 7: JSON-RPC Types

**Files:**
- Create: `src/mcp/mod.rs`
- Create: `src/mcp/protocol.rs`

**Step 1: Write test for JSON-RPC serialization**

Create `src/mcp/mod.rs`:
```rust
mod protocol;

pub use protocol::*;
```

Create `src/mcp/protocol.rs`:
```rust
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// JSON-RPC 2.0 Request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonRpcRequest {
    pub jsonrpc: String,
    pub id: u64,
    pub method: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub params: Option<Value>,
}

impl JsonRpcRequest {
    pub fn new(id: u64, method: impl Into<String>, params: Option<Value>) -> Self {
        Self {
            jsonrpc: "2.0".to_string(),
            id,
            method: method.into(),
            params,
        }
    }
}

/// JSON-RPC 2.0 Response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonRpcResponse {
    pub jsonrpc: String,
    pub id: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<JsonRpcError>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonRpcError {
    pub code: i32,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Value>,
}

/// MCP Initialize params
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct InitializeParams {
    pub protocol_version: String,
    pub capabilities: ClientCapabilities,
    pub client_info: ClientInfo,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ClientCapabilities {}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientInfo {
    pub name: String,
    pub version: String,
}

/// MCP Initialize result
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct InitializeResult {
    pub protocol_version: String,
    pub capabilities: ServerCapabilities,
    pub server_info: ServerInfo,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ServerCapabilities {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<ToolsCapability>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ToolsCapability {
    #[serde(default)]
    pub list_changed: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerInfo {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// MCP Tool definition
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Tool {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_schema: Option<Value>,
}

/// MCP tools/list result
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolsListResult {
    pub tools: Vec<Tool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_cursor: Option<String>,
}

/// MCP tools/call params
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCallParams {
    pub name: String,
    #[serde(default)]
    pub arguments: HashMap<String, Value>,
}

/// MCP tools/call result
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolCallResult {
    pub content: Vec<ContentItem>,
    #[serde(default)]
    pub is_error: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum ContentItem {
    Text { text: String },
    Image { data: String, mime_type: String },
    Resource { resource: Value },
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_jsonrpc_request_serialization() {
        let req = JsonRpcRequest::new(1, "tools/list", None);
        let json = serde_json::to_string(&req).unwrap();
        assert!(json.contains("\"jsonrpc\":\"2.0\""));
        assert!(json.contains("\"method\":\"tools/list\""));
    }

    #[test]
    fn test_tool_deserialization() {
        let json = r#"{
            "name": "get_weather",
            "description": "Get weather for a location",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "location": { "type": "string" }
                },
                "required": ["location"]
            }
        }"#;

        let tool: Tool = serde_json::from_str(json).unwrap();
        assert_eq!(tool.name, "get_weather");
        assert!(tool.input_schema.is_some());
    }

    #[test]
    fn test_tool_call_result_deserialization() {
        let json = r#"{
            "content": [
                { "type": "text", "text": "Weather: Sunny, 72F" }
            ],
            "isError": false
        }"#;

        let result: ToolCallResult = serde_json::from_str(json).unwrap();
        assert_eq!(result.content.len(), 1);
        assert!(!result.is_error);
    }
}
```

**Step 2: Run tests**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test protocol
```
Expected: PASS

**Step 3: Update main.rs**

Add to main.rs:
```rust
mod mcp;
```

**Step 4: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add MCP protocol types"
```

---

## Phase 4: Transport Layer

### Task 8: Transport Trait

**Files:**
- Create: `src/mcp/transport/mod.rs`
- Create: `src/mcp/transport/traits.rs`

**Step 1: Define transport trait**

Create `src/mcp/transport/mod.rs`:
```rust
mod traits;
mod stdio;
mod http;

pub use traits::*;
pub use stdio::StdioTransport;
pub use http::HttpTransport;
```

Create `src/mcp/transport/traits.rs`:
```rust
use crate::mcp::{JsonRpcRequest, JsonRpcResponse};
use anyhow::Result;
use async_trait::async_trait;

#[async_trait]
pub trait Transport: Send + Sync {
    /// Send a request and receive a response
    async fn request(&mut self, req: JsonRpcRequest) -> Result<JsonRpcResponse>;

    /// Close the transport
    async fn close(&mut self) -> Result<()>;
}
```

Add async-trait to Cargo.toml:
```toml
async-trait = "0.1"
```

**Step 2: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add transport trait"
```

---

### Task 9: Stdio Transport

**Files:**
- Create: `src/mcp/transport/stdio.rs`

**Step 1: Implement stdio transport**

Create `src/mcp/transport/stdio.rs`:
```rust
use super::Transport;
use crate::mcp::{JsonRpcRequest, JsonRpcResponse};
use anyhow::{bail, Context, Result};
use async_trait::async_trait;
use std::collections::HashMap;
use std::process::Stdio;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::process::{Child, Command};

pub struct StdioTransport {
    child: Child,
    stdin: tokio::process::ChildStdin,
    stdout: BufReader<tokio::process::ChildStdout>,
}

impl StdioTransport {
    pub async fn spawn(command: &str, env: HashMap<String, String>) -> Result<Self> {
        // Parse command - first word is the program, rest are args
        let parts: Vec<&str> = command.split_whitespace().collect();
        if parts.is_empty() {
            bail!("Empty command");
        }

        let (program, args) = parts.split_first().unwrap();

        let mut cmd = Command::new(program);
        cmd.args(args)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit())
            .envs(env);

        let mut child = cmd.spawn().with_context(|| format!("Failed to spawn: {}", command))?;

        let stdin = child.stdin.take().context("Failed to get stdin")?;
        let stdout = child.stdout.take().context("Failed to get stdout")?;

        Ok(Self {
            child,
            stdin,
            stdout: BufReader::new(stdout),
        })
    }
}

#[async_trait]
impl Transport for StdioTransport {
    async fn request(&mut self, req: JsonRpcRequest) -> Result<JsonRpcResponse> {
        // Write request as JSON line
        let mut json = serde_json::to_string(&req)?;
        json.push('\n');

        self.stdin.write_all(json.as_bytes()).await?;
        self.stdin.flush().await?;

        // Read response line
        let mut line = String::new();
        self.stdout.read_line(&mut line).await?;

        if line.is_empty() {
            bail!("Server closed connection unexpectedly");
        }

        let response: JsonRpcResponse = serde_json::from_str(&line)
            .with_context(|| format!("Failed to parse response: {}", line))?;

        Ok(response)
    }

    async fn close(&mut self) -> Result<()> {
        drop(self.stdin.by_ref());
        self.child.kill().await.ok();
        Ok(())
    }
}
```

**Step 2: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add stdio transport"
```

---

### Task 10: HTTP Transport

**Files:**
- Create: `src/mcp/transport/http.rs`

**Step 1: Implement HTTP transport**

Create `src/mcp/transport/http.rs`:
```rust
use super::Transport;
use crate::mcp::{JsonRpcRequest, JsonRpcResponse};
use anyhow::{Context, Result};
use async_trait::async_trait;
use reqwest::Client;

pub struct HttpTransport {
    client: Client,
    url: String,
}

impl HttpTransport {
    pub fn new(url: String) -> Self {
        Self {
            client: Client::new(),
            url,
        }
    }
}

#[async_trait]
impl Transport for HttpTransport {
    async fn request(&mut self, req: JsonRpcRequest) -> Result<JsonRpcResponse> {
        let response = self
            .client
            .post(&self.url)
            .json(&req)
            .send()
            .await
            .with_context(|| format!("Failed to send request to {}", self.url))?;

        let response: JsonRpcResponse = response
            .json()
            .await
            .context("Failed to parse JSON-RPC response")?;

        Ok(response)
    }

    async fn close(&mut self) -> Result<()> {
        Ok(())
    }
}
```

**Step 2: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add HTTP transport"
```

---

## Phase 5: MCP Client

### Task 11: MCP Client Implementation

**Files:**
- Create: `src/mcp/client.rs`
- Modify: `src/mcp/mod.rs`

**Step 1: Implement MCP client**

Create `src/mcp/client.rs`:
```rust
use super::protocol::*;
use super::transport::Transport;
use anyhow::{bail, Context, Result};
use serde_json::{json, Value};
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};

const PROTOCOL_VERSION: &str = "2024-11-05";

pub struct McpClient {
    transport: Box<dyn Transport>,
    request_id: AtomicU64,
    server_info: Option<ServerInfo>,
}

impl McpClient {
    pub fn new(transport: Box<dyn Transport>) -> Self {
        Self {
            transport,
            request_id: AtomicU64::new(1),
            server_info: None,
        }
    }

    fn next_id(&self) -> u64 {
        self.request_id.fetch_add(1, Ordering::SeqCst)
    }

    /// Initialize the MCP connection
    pub async fn initialize(&mut self) -> Result<InitializeResult> {
        let params = InitializeParams {
            protocol_version: PROTOCOL_VERSION.to_string(),
            capabilities: ClientCapabilities::default(),
            client_info: ClientInfo {
                name: "relay".to_string(),
                version: env!("CARGO_PKG_VERSION").to_string(),
            },
        };

        let req = JsonRpcRequest::new(
            self.next_id(),
            "initialize",
            Some(serde_json::to_value(params)?),
        );

        let response = self.transport.request(req).await?;

        if let Some(error) = response.error {
            bail!("Initialize failed: {} (code {})", error.message, error.code);
        }

        let result: InitializeResult = serde_json::from_value(
            response.result.context("No result in initialize response")?,
        )?;

        self.server_info = Some(result.server_info.clone());

        // Send initialized notification
        let notif = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            id: self.next_id(),
            method: "notifications/initialized".to_string(),
            params: None,
        };
        // Fire and forget - notifications don't get responses in MCP
        // For stdio, we still need to send it but ignore response handling

        Ok(result)
    }

    /// List all available tools
    pub async fn list_tools(&mut self) -> Result<Vec<Tool>> {
        let mut all_tools = Vec::new();
        let mut cursor: Option<String> = None;

        loop {
            let params = cursor.as_ref().map(|c| json!({ "cursor": c }));
            let req = JsonRpcRequest::new(self.next_id(), "tools/list", params);
            let response = self.transport.request(req).await?;

            if let Some(error) = response.error {
                bail!("tools/list failed: {} (code {})", error.message, error.code);
            }

            let result: ToolsListResult = serde_json::from_value(
                response.result.context("No result in tools/list response")?,
            )?;

            all_tools.extend(result.tools);

            match result.next_cursor {
                Some(next) => cursor = Some(next),
                None => break,
            }
        }

        Ok(all_tools)
    }

    /// Call a tool with arguments
    pub async fn call_tool(
        &mut self,
        name: &str,
        arguments: HashMap<String, Value>,
    ) -> Result<ToolCallResult> {
        let params = ToolCallParams {
            name: name.to_string(),
            arguments,
        };

        let req = JsonRpcRequest::new(
            self.next_id(),
            "tools/call",
            Some(serde_json::to_value(params)?),
        );

        let response = self.transport.request(req).await?;

        if let Some(error) = response.error {
            bail!("tools/call failed: {} (code {})", error.message, error.code);
        }

        let result: ToolCallResult = serde_json::from_value(
            response.result.context("No result in tools/call response")?,
        )?;

        Ok(result)
    }

    /// Get server info (after initialization)
    pub fn server_info(&self) -> Option<&ServerInfo> {
        self.server_info.as_ref()
    }

    /// Close the connection
    pub async fn close(&mut self) -> Result<()> {
        self.transport.close().await
    }
}
```

**Step 2: Update mod.rs**

Update `src/mcp/mod.rs`:
```rust
mod protocol;
mod client;
pub mod transport;

pub use protocol::*;
pub use client::McpClient;
```

**Step 3: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add MCP client"
```

---

## Phase 6: Discovery Commands

### Task 12: Connect Helper

**Files:**
- Create: `src/commands/connect.rs`
- Modify: `src/commands/mod.rs`

**Step 1: Create connection helper**

Create `src/commands/connect.rs`:
```rust
use crate::config::{interpolate_env_map, Config, ConfigStore, TransportConfig};
use crate::mcp::transport::{HttpTransport, StdioTransport, Transport};
use crate::mcp::McpClient;
use anyhow::{bail, Context, Result};

/// Resolve server name, using default if not specified
pub fn resolve_server_name(config: &Config, server: Option<String>) -> Result<String> {
    match server {
        Some(name) => Ok(name),
        None => config
            .default_server
            .clone()
            .context("No server specified and no default server set. Use `relay add` to add a server."),
    }
}

/// Create a connected MCP client for a server
pub async fn connect(store: &ConfigStore, server_name: &str) -> Result<McpClient> {
    let config = store.load()?;

    let server_config = config
        .servers
        .get(server_name)
        .with_context(|| format!("Server '{}' not found", server_name))?;

    let env = interpolate_env_map(&server_config.env);

    let transport: Box<dyn Transport> = match &server_config.transport {
        TransportConfig::Stdio { command } => {
            Box::new(StdioTransport::spawn(command, env).await?)
        }
        TransportConfig::Http { url } => {
            Box::new(HttpTransport::new(url.clone()))
        }
    };

    let mut client = McpClient::new(transport);
    client.initialize().await?;

    Ok(client)
}
```

**Step 2: Update commands mod**

Update `src/commands/mod.rs`:
```rust
mod server;
mod connect;

pub use server::*;
pub use connect::*;
```

**Step 3: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add connection helper"
```

---

### Task 13: Ping Command

**Files:**
- Create: `src/commands/ping.rs`
- Modify: `src/commands/mod.rs`
- Modify: `src/main.rs`

**Step 1: Implement ping command**

Create `src/commands/ping.rs`:
```rust
use crate::cli::OutputFormat;
use crate::commands::connect;
use crate::config::ConfigStore;
use anyhow::Result;
use owo_colors::OwoColorize;
use std::time::Instant;

pub async fn ping_server(store: &ConfigStore, name: &str, format: OutputFormat) -> Result<()> {
    let start = Instant::now();

    let mut client = connect(store, name).await?;
    let elapsed = start.elapsed();

    let server_info = client.server_info().cloned();
    client.close().await?;

    match format {
        OutputFormat::Human => {
            let ms = elapsed.as_secs_f64() * 1000.0;
            if let Some(info) = server_info {
                println!(
                    "{} Connected to {} {} in {}",
                    "✓".green(),
                    info.name.cyan(),
                    format!("v{}", info.version.unwrap_or_else(|| "?".to_string())).dimmed(),
                    format!("{:.2}ms", ms).yellow()
                );
            } else {
                println!(
                    "{} Connected in {}",
                    "✓".green(),
                    format!("{:.2}ms", ms).yellow()
                );
            }
        }
        OutputFormat::Json => {
            let output = serde_json::json!({
                "status": "ok",
                "server": server_info,
                "elapsed_ms": elapsed.as_secs_f64() * 1000.0
            });
            println!("{}", serde_json::to_string_pretty(&output)?);
        }
    }

    Ok(())
}
```

**Step 2: Update commands mod**

Add to `src/commands/mod.rs`:
```rust
mod ping;
pub use ping::*;
```

**Step 3: Update main.rs**

Add to match in main.rs:
```rust
Commands::Ping { name } => {
    commands::ping_server(&store, &name, cli.format).await?;
}
```

**Step 4: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add ping command"
```

---

### Task 14: Tools Command

**Files:**
- Create: `src/commands/tools.rs`
- Modify: `src/commands/mod.rs`
- Modify: `src/main.rs`

**Step 1: Implement tools command**

Create `src/commands/tools.rs`:
```rust
use crate::cli::OutputFormat;
use crate::commands::{connect, resolve_server_name};
use crate::config::ConfigStore;
use crate::mcp::Tool;
use anyhow::Result;
use owo_colors::OwoColorize;

pub async fn list_tools(
    store: &ConfigStore,
    server: Option<String>,
    format: OutputFormat,
) -> Result<()> {
    let config = store.load()?;
    let server_name = resolve_server_name(&config, server)?;

    let mut client = connect(store, &server_name).await?;
    let tools = client.list_tools().await?;
    client.close().await?;

    match format {
        OutputFormat::Human => {
            if tools.is_empty() {
                println!(
                    "{}",
                    format!("No tools available from server '{}'", server_name).dimmed()
                );
                return Ok(());
            }

            println!("Tools from {}:", server_name.cyan());
            println!();

            for tool in &tools {
                println!("  {}", tool.name.green().bold());
                if let Some(desc) = &tool.description {
                    for line in textwrap::wrap(desc, 56) {
                        println!("    {}", line.dimmed());
                    }
                }
                println!();
            }

            println!(
                "{}",
                format!("Total: {} tool(s)", tools.len()).dimmed()
            );
        }
        OutputFormat::Json => {
            let output = serde_json::json!({
                "server": server_name,
                "tools": tools
            });
            println!("{}", serde_json::to_string_pretty(&output)?);
        }
    }

    Ok(())
}

pub async fn describe_tool(
    store: &ConfigStore,
    server: Option<String>,
    tool_name: &str,
    format: OutputFormat,
) -> Result<()> {
    let config = store.load()?;
    let server_name = resolve_server_name(&config, server)?;

    let mut client = connect(store, &server_name).await?;
    let tools = client.list_tools().await?;
    client.close().await?;

    let tool = tools
        .iter()
        .find(|t| t.name == tool_name)
        .ok_or_else(|| anyhow::anyhow!("Tool '{}' not found on server '{}'", tool_name, server_name))?;

    match format {
        OutputFormat::Human => {
            println!("{}: {}", "Tool".bold(), tool.name.cyan());
            println!();

            if let Some(desc) = &tool.description {
                println!("{}:", "Description".bold());
                for line in textwrap::wrap(desc, 70) {
                    println!("  {}", line);
                }
                println!();
            }

            if let Some(schema) = &tool.input_schema {
                println!("{}:", "Input Schema".bold());
                println!("{}", serde_json::to_string_pretty(schema)?);
            } else {
                println!("{}", "No input schema defined".dimmed());
            }
        }
        OutputFormat::Json => {
            println!("{}", serde_json::to_string_pretty(tool)?);
        }
    }

    Ok(())
}
```

Add textwrap to Cargo.toml:
```toml
textwrap = "0.16"
```

**Step 2: Update commands mod**

Add to `src/commands/mod.rs`:
```rust
mod tools;
pub use tools::*;
```

**Step 3: Update main.rs**

Add to match in main.rs:
```rust
Commands::Tools { server } => {
    commands::list_tools(&store, server, cli.format).await?;
}
Commands::Describe { server, tool } => {
    commands::describe_tool(&store, server, &tool, cli.format).await?;
}
```

**Step 4: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add tools and describe commands"
```

---

## Phase 7: Tool Invocation

### Task 15: Schema to Flags Mapper

**Files:**
- Create: `src/schema/mod.rs`
- Create: `src/schema/flags.rs`

**Step 1: Implement schema parser**

Create `src/schema/mod.rs`:
```rust
mod flags;

pub use flags::*;
```

Create `src/schema/flags.rs`:
```rust
use anyhow::{bail, Result};
use serde_json::Value;
use std::collections::HashMap;

/// Represents a parsed flag from JSON Schema
#[derive(Debug, Clone)]
pub struct SchemaFlag {
    pub name: String,
    pub description: Option<String>,
    pub required: bool,
    pub flag_type: FlagType,
    pub default: Option<Value>,
}

#[derive(Debug, Clone)]
pub enum FlagType {
    String,
    Integer,
    Number,
    Boolean,
    Array(Box<FlagType>),
    Object, // Escape hatch - requires JSON input
    Enum(Vec<String>),
}

/// Parse JSON Schema into CLI flags
pub fn parse_schema(schema: &Value) -> Result<Vec<SchemaFlag>> {
    let mut flags = Vec::new();

    let properties = schema
        .get("properties")
        .and_then(|p| p.as_object())
        .unwrap_or(&serde_json::Map::new())
        .clone();

    let required: Vec<String> = schema
        .get("required")
        .and_then(|r| r.as_array())
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_str().map(String::from))
                .collect()
        })
        .unwrap_or_default();

    for (name, prop) in properties {
        let flag_type = parse_type(&prop)?;
        let description = prop.get("description").and_then(|d| d.as_str()).map(String::from);
        let default = prop.get("default").cloned();

        flags.push(SchemaFlag {
            name: name.clone(),
            description,
            required: required.contains(&name),
            flag_type,
            default,
        });
    }

    // Sort: required first, then alphabetically
    flags.sort_by(|a, b| {
        match (a.required, b.required) {
            (true, false) => std::cmp::Ordering::Less,
            (false, true) => std::cmp::Ordering::Greater,
            _ => a.name.cmp(&b.name),
        }
    });

    Ok(flags)
}

fn parse_type(prop: &Value) -> Result<FlagType> {
    // Check for enum first
    if let Some(enum_values) = prop.get("enum").and_then(|e| e.as_array()) {
        let values: Vec<String> = enum_values
            .iter()
            .filter_map(|v| v.as_str().map(String::from))
            .collect();
        return Ok(FlagType::Enum(values));
    }

    let type_str = prop
        .get("type")
        .and_then(|t| t.as_str())
        .unwrap_or("string");

    match type_str {
        "string" => Ok(FlagType::String),
        "integer" => Ok(FlagType::Integer),
        "number" => Ok(FlagType::Number),
        "boolean" => Ok(FlagType::Boolean),
        "array" => {
            let items = prop.get("items").unwrap_or(&Value::Null);
            let item_type = parse_type(items)?;
            Ok(FlagType::Array(Box::new(item_type)))
        }
        "object" => Ok(FlagType::Object),
        other => {
            // Default to string for unknown types
            Ok(FlagType::String)
        }
    }
}

/// Parse CLI args into JSON values based on schema
pub fn parse_args(args: &[String], flags: &[SchemaFlag]) -> Result<HashMap<String, Value>> {
    let mut result = HashMap::new();
    let mut i = 0;

    while i < args.len() {
        let arg = &args[i];

        if !arg.starts_with("--") {
            bail!("Unexpected argument: {}. Use --name value format.", arg);
        }

        let flag_name = arg.trim_start_matches("--");

        // Find the flag definition
        let flag = flags
            .iter()
            .find(|f| f.name == flag_name || f.name.replace('_', "-") == flag_name)
            .ok_or_else(|| anyhow::anyhow!("Unknown flag: --{}", flag_name))?;

        let value = match &flag.flag_type {
            FlagType::Boolean => {
                // Boolean flags don't require a value
                Value::Bool(true)
            }
            _ => {
                i += 1;
                if i >= args.len() {
                    bail!("Flag --{} requires a value", flag_name);
                }
                parse_value(&args[i], &flag.flag_type)?
            }
        };

        result.insert(flag.name.clone(), value);
        i += 1;
    }

    // Apply defaults for missing optional flags
    for flag in flags {
        if !result.contains_key(&flag.name) {
            if let Some(default) = &flag.default {
                result.insert(flag.name.clone(), default.clone());
            } else if flag.required {
                bail!("Missing required flag: --{}", flag.name);
            }
        }
    }

    Ok(result)
}

fn parse_value(s: &str, flag_type: &FlagType) -> Result<Value> {
    match flag_type {
        FlagType::String => Ok(Value::String(s.to_string())),
        FlagType::Integer => {
            let n: i64 = s.parse().map_err(|_| anyhow::anyhow!("Invalid integer: {}", s))?;
            Ok(Value::Number(n.into()))
        }
        FlagType::Number => {
            let n: f64 = s.parse().map_err(|_| anyhow::anyhow!("Invalid number: {}", s))?;
            Ok(serde_json::Number::from_f64(n)
                .map(Value::Number)
                .unwrap_or(Value::Null))
        }
        FlagType::Boolean => {
            let b = match s.to_lowercase().as_str() {
                "true" | "1" | "yes" => true,
                "false" | "0" | "no" => false,
                _ => bail!("Invalid boolean: {}", s),
            };
            Ok(Value::Bool(b))
        }
        FlagType::Enum(values) => {
            if values.contains(&s.to_string()) {
                Ok(Value::String(s.to_string()))
            } else {
                bail!("Invalid value '{}'. Must be one of: {}", s, values.join(", "))
            }
        }
        FlagType::Array(_) => {
            // For arrays, try to parse as JSON, or treat as single-element array
            if s.starts_with('[') {
                serde_json::from_str(s).map_err(|e| anyhow::anyhow!("Invalid JSON array: {}", e))
            } else {
                Ok(Value::Array(vec![Value::String(s.to_string())]))
            }
        }
        FlagType::Object => {
            serde_json::from_str(s).map_err(|e| anyhow::anyhow!("Invalid JSON object: {}", e))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_parse_simple_schema() {
        let schema = json!({
            "type": "object",
            "properties": {
                "name": { "type": "string", "description": "The name" },
                "count": { "type": "integer" }
            },
            "required": ["name"]
        });

        let flags = parse_schema(&schema).unwrap();
        assert_eq!(flags.len(), 2);
        assert!(flags[0].required); // name should be first (required)
        assert_eq!(flags[0].name, "name");
    }

    #[test]
    fn test_parse_args() {
        let schema = json!({
            "type": "object",
            "properties": {
                "title": { "type": "string" },
                "count": { "type": "integer" }
            },
            "required": ["title"]
        });

        let flags = parse_schema(&schema).unwrap();
        let args = vec![
            "--title".to_string(),
            "Hello".to_string(),
            "--count".to_string(),
            "5".to_string(),
        ];

        let result = parse_args(&args, &flags).unwrap();
        assert_eq!(result.get("title"), Some(&Value::String("Hello".to_string())));
        assert_eq!(result.get("count"), Some(&Value::Number(5.into())));
    }

    #[test]
    fn test_parse_enum() {
        let schema = json!({
            "type": "object",
            "properties": {
                "priority": {
                    "type": "string",
                    "enum": ["low", "medium", "high"]
                }
            }
        });

        let flags = parse_schema(&schema).unwrap();
        assert!(matches!(flags[0].flag_type, FlagType::Enum(_)));
    }
}
```

**Step 2: Add to main**

Add to main.rs:
```rust
mod schema;
```

**Step 3: Run tests**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test schema
```
Expected: PASS

**Step 4: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add schema to flags mapper"
```

---

### Task 16: Run Command

**Files:**
- Create: `src/commands/run.rs`
- Modify: `src/commands/mod.rs`
- Modify: `src/main.rs`

**Step 1: Implement run command**

Create `src/commands/run.rs`:
```rust
use crate::cli::OutputFormat;
use crate::commands::{connect, resolve_server_name};
use crate::config::ConfigStore;
use crate::mcp::ContentItem;
use crate::schema::{parse_args, parse_schema};
use anyhow::{bail, Context, Result};
use owo_colors::OwoColorize;
use serde_json::Value;
use std::collections::HashMap;

pub async fn run_tool(
    store: &ConfigStore,
    server: Option<String>,
    tool_name: &str,
    input_json: Option<String>,
    args: Vec<String>,
    format: OutputFormat,
) -> Result<()> {
    let config = store.load()?;
    let server_name = resolve_server_name(&config, server)?;

    let mut client = connect(store, &server_name).await?;

    // Find the tool to get its schema
    let tools = client.list_tools().await?;
    let tool = tools
        .iter()
        .find(|t| t.name == tool_name)
        .ok_or_else(|| anyhow::anyhow!("Tool '{}' not found on server '{}'", tool_name, server_name))?;

    // Build arguments
    let arguments: HashMap<String, Value> = if let Some(json_str) = input_json {
        serde_json::from_str(&json_str).context("Invalid --input-json")?
    } else if !args.is_empty() {
        // Parse args using schema
        let schema = tool.input_schema.as_ref().unwrap_or(&Value::Null);
        let flags = parse_schema(schema)?;
        parse_args(&args, &flags)?
    } else {
        HashMap::new()
    };

    // Call the tool
    let result = client.call_tool(tool_name, arguments).await?;
    client.close().await?;

    // Render output
    match format {
        OutputFormat::Human => {
            if result.is_error {
                eprintln!("{} {}", "✗".red(), "Error from tool:".red().bold());
            }

            for item in &result.content {
                match item {
                    ContentItem::Text { text } => {
                        println!("{}", text);
                    }
                    ContentItem::Image { data, mime_type } => {
                        println!(
                            "{} {} {}",
                            "[Image]".magenta(),
                            mime_type.dimmed(),
                            format!("({} bytes)", data.len()).dimmed()
                        );
                    }
                    ContentItem::Resource { resource } => {
                        println!(
                            "{}\n{}",
                            "[Resource]".magenta(),
                            serde_json::to_string_pretty(resource)?
                        );
                    }
                }
            }
        }
        OutputFormat::Json => {
            println!("{}", serde_json::to_string_pretty(&result)?);
        }
    }

    if result.is_error {
        std::process::exit(1);
    }

    Ok(())
}
```

**Step 2: Update commands mod**

Add to `src/commands/mod.rs`:
```rust
mod run;
pub use run::*;
```

**Step 3: Update main.rs**

Add to match in main.rs:
```rust
Commands::Run { server, tool, input_json, args } => {
    commands::run_tool(&store, server, &tool, input_json, args, cli.format).await?;
}
```

**Step 4: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: add run command"
```

---

## Phase 8: Polish

### Task 17: Error Handling Improvements

**Files:**
- Create: `src/error.rs`
- Modify: `src/main.rs`

**Step 1: Add custom error types**

Create `src/error.rs`:
```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum RelayError {
    #[error("Server '{0}' not found")]
    ServerNotFound(String),

    #[error("Tool '{0}' not found on server '{1}'")]
    ToolNotFound(String, String),

    #[error("No default server configured. Use `relay add` to add a server.")]
    NoDefaultServer,

    #[error("Connection failed: {0}")]
    ConnectionFailed(String),

    #[error("MCP error: {message} (code {code})")]
    McpError { code: i32, message: String },

    #[error("Invalid argument: {0}")]
    InvalidArgument(String),

    #[error("Missing required flag: --{0}")]
    MissingRequiredFlag(String),
}
```

**Step 2: Update main.rs error handling**

Update main.rs:
```rust
mod error;

use owo_colors::OwoColorize;

// ... in main() ...

    let result = match cli.command {
        // ... existing match arms ...
    };

    if let Err(e) = result {
        eprintln!("{} {}", "error:".red().bold(), e);

        // Show cause chain in verbose mode
        if cli.verbose {
            let mut source = e.source();
            while let Some(cause) = source {
                eprintln!("  {} {}", "caused by:".dimmed(), cause);
                source = cause.source();
            }
        }

        std::process::exit(1);
    }
```

**Step 3: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "feat: improve error handling"
```

---

### Task 18: Integration Test with Mock Server

**Files:**
- Create: `tests/integration_test.rs`
- Create: `tests/mock_server.rs`

**Step 1: Create mock MCP server for testing**

Create `tests/mock_server.rs`:
```rust
use serde_json::{json, Value};
use std::io::{BufRead, BufReader, Write};

/// A simple mock MCP server for testing
pub fn run_mock_server() {
    let stdin = std::io::stdin();
    let mut stdout = std::io::stdout();
    let reader = BufReader::new(stdin);

    for line in reader.lines() {
        let line = line.unwrap();
        let request: Value = serde_json::from_str(&line).unwrap();

        let method = request["method"].as_str().unwrap_or("");
        let id = request["id"].as_u64().unwrap_or(0);

        let response = match method {
            "initialize" => json!({
                "jsonrpc": "2.0",
                "id": id,
                "result": {
                    "protocolVersion": "2024-11-05",
                    "capabilities": { "tools": {} },
                    "serverInfo": { "name": "mock-server", "version": "1.0.0" }
                }
            }),
            "tools/list" => json!({
                "jsonrpc": "2.0",
                "id": id,
                "result": {
                    "tools": [
                        {
                            "name": "echo",
                            "description": "Echo back a message",
                            "inputSchema": {
                                "type": "object",
                                "properties": {
                                    "message": { "type": "string", "description": "Message to echo" }
                                },
                                "required": ["message"]
                            }
                        }
                    ]
                }
            }),
            "tools/call" => {
                let args = &request["params"]["arguments"];
                let message = args["message"].as_str().unwrap_or("(no message)");
                json!({
                    "jsonrpc": "2.0",
                    "id": id,
                    "result": {
                        "content": [{ "type": "text", "text": format!("Echo: {}", message) }],
                        "isError": false
                    }
                })
            }
            _ => json!({
                "jsonrpc": "2.0",
                "id": id,
                "error": { "code": -32601, "message": "Method not found" }
            }),
        };

        writeln!(stdout, "{}", serde_json::to_string(&response).unwrap()).unwrap();
        stdout.flush().unwrap();
    }
}

fn main() {
    run_mock_server();
}
```

Add to Cargo.toml:
```toml
[[bin]]
name = "mock-server"
path = "tests/mock_server.rs"
```

**Step 2: Create integration test**

Create `tests/integration_test.rs`:
```rust
use assert_cmd::Command;
use predicates::prelude::*;
use tempfile::tempdir;

fn relay_cmd(config_path: &str) -> Command {
    let mut cmd = Command::cargo_bin("relay").unwrap();
    cmd.env("RELAY_CONFIG", config_path);
    cmd
}

#[test]
fn test_full_workflow() {
    let dir = tempdir().unwrap();
    let config_path = dir.path().join("config.yaml");
    let config_str = config_path.to_str().unwrap();

    // Build mock server first
    Command::new("cargo")
        .args(["build", "--bin", "mock-server"])
        .assert()
        .success();

    let mock_server_path = std::env::current_dir()
        .unwrap()
        .join("target/debug/mock-server");

    // Add mock server
    relay_cmd(config_str)
        .args([
            "add", "mock",
            "--transport", "stdio",
            "--cmd", mock_server_path.to_str().unwrap(),
        ])
        .assert()
        .success();

    // List servers
    relay_cmd(config_str)
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("mock"));

    // Ping server
    relay_cmd(config_str)
        .args(["ping", "mock"])
        .assert()
        .success()
        .stdout(predicate::str::contains("mock-server"));

    // List tools
    relay_cmd(config_str)
        .args(["tools", "mock"])
        .assert()
        .success()
        .stdout(predicate::str::contains("echo"));

    // Describe tool
    relay_cmd(config_str)
        .args(["describe", "mock", "echo"])
        .assert()
        .success()
        .stdout(predicate::str::contains("message"));

    // Run tool with flags
    relay_cmd(config_str)
        .args(["run", "mock", "echo", "--message", "Hello World"])
        .assert()
        .success()
        .stdout(predicate::str::contains("Echo: Hello World"));

    // Run tool with JSON input
    relay_cmd(config_str)
        .args(["run", "mock", "echo", "--input-json", r#"{"message": "JSON test"}"#])
        .assert()
        .success()
        .stdout(predicate::str::contains("Echo: JSON test"));

    // Run with --json output
    relay_cmd(config_str)
        .args(["run", "mock", "echo", "--message", "Test", "--json"])
        .assert()
        .success()
        .stdout(predicate::str::contains(r#""type": "text""#));
}
```

**Step 3: Run integration tests**

Run:
```bash
cd /Users/nickcramaro/Projects/relay && cargo test integration
```
Expected: PASS

**Step 4: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "test: add integration tests with mock server"
```

---

### Task 19: README

**Files:**
- Create: `README.md`

**Step 1: Create README**

Create `README.md`:
```markdown
# Relay

CLI interface for MCP (Model Context Protocol) servers.

## Installation

```bash
cargo install --path .
```

## Quick Start

```bash
# Add an MCP server
relay add linear \
  --transport stdio \
  --cmd "npx @linear/mcp-server" \
  --env LINEAR_API_KEY=your-key

# List available tools
relay tools

# Describe a tool
relay describe issue.create

# Run a tool
relay run issue.create \
  --title "Bug report" \
  --team ENG \
  --description "Found an issue"
```

## Commands

| Command | Description |
|---------|-------------|
| `relay add <name>` | Register an MCP server |
| `relay list` | List registered servers |
| `relay remove <name>` | Remove a server |
| `relay ping <name>` | Test server connectivity |
| `relay tools [server]` | List available tools |
| `relay describe [server] <tool>` | Show tool details |
| `relay run [server] <tool> [args]` | Execute a tool |

## Configuration

Config stored at `~/.config/relay/config.yaml`:

```yaml
servers:
  linear:
    transport: stdio
    command: "npx @linear/mcp-server"
    env:
      LINEAR_API_KEY: "${env:LINEAR_API_KEY}"

default_server: linear
```

## License

MIT
```

**Step 2: Commit**

```bash
cd /Users/nickcramaro/Projects/relay && git add -A && git commit -m "docs: add README"
```

---

## Summary

| Phase | Tasks | Description |
|-------|-------|-------------|
| 1 | 1-2 | Project skeleton, CLI scaffold |
| 2 | 3-6 | Config system (types, persistence, interpolation, commands) |
| 3 | 7 | MCP protocol types |
| 4 | 8-10 | Transport layer (trait, stdio, HTTP) |
| 5 | 11 | MCP client |
| 6 | 12-14 | Discovery commands (connect, ping, tools) |
| 7 | 15-16 | Tool invocation (schema mapper, run command) |
| 8 | 17-19 | Polish (errors, integration tests, README) |

**Total: 19 tasks, ~95 bite-sized steps**

Each task follows TDD: write failing test → implement → verify → commit.
